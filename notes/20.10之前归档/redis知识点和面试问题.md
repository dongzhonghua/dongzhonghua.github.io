[TOC]

## 使用redis有哪些好处？

1. 速度快，数据都在内存中。
2. 支持丰富的数据类型，支持String，list，set，sorted set，hash。
3. 支持事务，操作都是原子性，要么全部执行，要么全部不执行。
4. 丰富的特性：可用于缓存，消息，过期自动删除等。

## redis相比memcached有哪些优势？
1. memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
2. redis的速度比memcached快很多
3. redis可以持久化其数据

## redis最适合的场景
Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别。
1. session cache，可以会话缓存，而且提供持久化。分布式系统就可以使用这种方式。
2. 全页缓存（FPC），就相当于缓存网页，以更快的速度加载曾经浏览过的网页。
3. 消息队列。队列 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
4. 排行榜/计数器 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。（这个用处非常常见）
5. 发布/订阅模式。

## redis分布式锁
### 分布式锁
- 加锁
在沙滩上踩一脚，留下自己的脚印，其他进程或者线程，看见脚印，就知道锁被别人持有，则等待。
- 解锁
把脚印从沙滩上抹去，就是解锁的过程。
- 锁超时
为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。

分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。
### redis分布式锁
- 加锁
  加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。
  ```SET lock_key random_value NX PX 5000```
  成功返回OK，否则返回nil。
  值得注意的是：
  random_value 是客户端生成的唯一的字符串。
  NX 代表只在键不存在时，才对键进行设置操作。
  PX 5000 设置键的过期时间为5000毫秒。

  这样，如果上面的命令执行成功，则证明客户端获取到了锁。

- 解锁

  解锁的过程就是将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉。这时候random_value的作用就体现出来。

  先判断key和value是不是相等，是的话就删除。

## 如果有大量的key需要设置同一时间过期，一般需要注意什么？

如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

## redis持久化机制

bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。 

## Redis的同步机制了解么？

Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

## Redis 集群方案与实现

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。