[TOC]

## jvm 

## jvm内存模型

<img src="http://www.dsvshx.xyz:9001/images/jvm内存模型.png" style="zoom: 50%;" />

### 堆
存放对象实例，java代码中所有的new操作，几乎所有的对象实例都在这里分配内存
- 堆得内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
- 默认空余的堆内存小于40%时，就会增大，直到-Xmx设置的内存。具体的比例可以由-XX:MinHeapFreeRatio指定
- 空余的内存大于70%时，就会减少内存，直到-Xms设置的大小。具体由-XX:MaxHeapFreeRatio指定。

### 虚拟机栈
虚拟机栈是用于描述java方法执行的内存模型 ：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。

虚拟机栈是线程隔离的。

 <img src="http://www.dsvshx.xyz:9001/images/虚拟机栈工作模型.png" style="zoom: 50%;" /> 

本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。 

### 方法区
存储已被虚拟机加载的类元数据信息(元空间)
- 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
- 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
该区域是被线程共享的。
- 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

### 程序计数器
当前线程所执行的字节码的行号指示器

## JVM垃圾回收算法

JVM GC只回收堆区和方法区的对象。

### 标记-清除
标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。 

 <img src="http://www.dsvshx.xyz:9001/images/标记清除算法.png" style="zoom:50%;" /> 

### 复制算法
   为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。
   但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存叫Eden（伊甸园）区，其余是两块较小的内存区叫Survior区。
   每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)

 <img src="http://www.dsvshx.xyz:9001/images/复制算法.png" style="zoom:50%;" /> 

### 标记-整理
主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 

 <img src="http://www.dsvshx.xyz:9001/images/标记整理算法.png" style="zoom:50%;" /> 

### 分代收集
现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

## JVM垃圾收集器有哪些？以及优劣势比较？

| 收集器     | 特点                                     |
| ---------- | ---------------------------------------- |
| 串行收集器 | 暂停所有应用的线程来工作，单线程         |
| 并行收集器 | 默认的垃圾收集器。暂停所有应用，多线程。 |
| CMS收集器  | 多线程扫描，标记需要回收的实例，清除。   |
| G1收集器   | 用于大堆区域。对内存分割，并发回收。     |



### 串行收集器

只使用**一个线程**去回收。新生代、老年代使用**串行**回收；**新生代复制算法**、**老年代标记-压缩**；垃圾收集的过程中会Stop The World（服务暂停） 

 <img src="http://www.dsvshx.xyz:9001/images/串行收集器.png" style="zoom:50%;" /> 

### 并行收集器 

 Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的**吞吐量**。 

### CMS收集器 

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。

 <img src="http://www.dsvshx.xyz:9001/images/CMS收集器.png" style="zoom:50%;" /> 

从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

### G1收集器 

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：

空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。
可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

##  在JVM中，如何判断一个对象是否死亡？ 

###  引用计数法 

 引用计数法是最简单最古老的算法，JVM为每个对象分配一个计数器，当对象被引用时，计数器就加1，当对象没有被引用或者离开作用域，计数器就减1。当计数器的值为0时，就代表该对象已经死亡 

###  可达性分析算法

用GCROOTs 作为对象的起点开始往下搜索，能搜索到这个对象，就表示对象是可达的，不能搜素到表示对象是不可达的：
可作为GCRoots的对象包括下面几种：

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中引用的对象

## 谈谈JVM中，对类加载器的认识

类加载器是JVM的组成部分之一。将字节码文件加载进JVM。

类加载分为四部分：

1. BootStrapClassLoader，即跟类加载器，加载java运行时所需的类，如String，Integer等存在${java_home}/jre/lib/rt.jar包类的所有类。

2. ExtensionClassLoader,扩展类加载器，加载一些扩展类，即${java_home}/jre/lib/ext/*.jar包

3. AppClassLoader，系统加载类，加载自定义的类，级classpath下的所有类

4. ClassLoader 抽象类加载器：用户自定义的类加载器，用户定义的类加载器都要继承次ClassLoader

Jvm默认采用的是双亲委派类加载机制， 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 

## 堆和栈**♥** &hearts; 

**栈内存**：栈内存首先是一片内存空间，存储都是局部变量，凡是定义在方法中的都是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后在定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

**堆内存**：存储的是数组和对象（其实数据就是对象），凡是new建立的都是在堆中，堆中存放的都是实体对象，实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以对是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，就没有了。堆里的实体虽然不会被释放，但是会被GC不定时的回收。

 <img src="http://www.dsvshx.xyz:9001/images/堆和栈分配内存.png" style="zoom:50%;" /> 

 比如主函数里的语句  int [] arr=new int [3];在内存中是怎么被定义的：

- 主函数先进栈，在栈中定义一个变量arr，接下来为arr赋值，但是右边不是一个具体的值，是一个实体。实体创建在堆里，在堆里首先通过new关键字开辟一个空间，内存在存储数据的时候都是通过地址来体现的，地址是一块连续的二进制，然后给这个实体分配一个内存地址。 数组都是有一个索引，数组这个实体在堆内存中产生之后每一个空间都会进行默认的初始化（这是堆内存的特点，未初始化的数据是不能用的，但在堆里是可以用的，因为初始化过了，但是在栈里没有），不同的类型初始化的值不一样。 
- 就是栈中定义变量，堆中创建实体，初始化实体，返回一个地址。

那么栈和堆是怎么联系起来的呢？

我们刚刚说过给对分配了一个地址，把堆的地址赋值给arr，arr就通过地址指向了数组。arr想操纵数组就通过地址，而不是直接把实体赋给它。这种我们不在叫他基本数据类型，而叫引用数据类型，称为arr引用了堆内存当中的实体。

如果是int[] arr = null;则arr不坐任何指向，null的作用就是取消引用数据类型的指向。

当一个实体，没有引用数据类型指向的时候，它在堆内存中不会被释放，而被当做一个垃圾，在不定时的时间内自动回收，因为Java有一个自动回收机制，（而c++没有，需要程序员手动回收，如果不回收就越堆越多，直到撑满内存溢出，所以Java在内存管理上优于c++）。自动回收机制（程序）自动监测堆里是否有垃圾，如果有，就会自动的做垃圾回收的动作，但是什么时候收不一定。


所以堆和栈的区别很明显：

- 栈内存存储的是局部变量二堆内存存储的是实体；
- 占内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
- 栈内存存放的变量生命周期一旦结束就会被释放，而堆内存是等着GC回收。