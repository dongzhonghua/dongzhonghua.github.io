# 操作系统常见的知识点和面试总结

## 问题总结

1. 进程和线程的关系以及区别

2.  进程间通信有哪些方式？它们的区别？ 

3.  线程间的通信机制  

4.  Windows下的内存是如何管理的 

5.  中断和轮询的特点 

6.  什么是临界区、如何解决冲突？ 

7.  分段和分页的区别？ 

8.  什么是死锁？产生条件？如何避免死锁 

9.  进程间同步与互斥的区别，线程同步的方式？ 

10.  进程的调度算法有哪些？ 

## 一、进程和线程的关系以及区别
1. 定义：
    进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 
    　　线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 

2. 关系

   　　一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 
        　　相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 

3. 区别

   ![](https://img-blog.csdn.net/20180807102231621?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25nbHVvMDYyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4. 优缺点 
   线程开销小，但不利于资源的管理和保护；进程与之相反。 

5. 协程

    协程是单线程下实现多任务，它通过 yield 关键字来实现，能有效地减少多线程之间切换的开销。它是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。  协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），性能得到了很大的提升，不会像线程切换那样消耗资源。  异步代码，可能不那么容易理解和调度。 协程共享堆，不共享栈。
   
   协程之间通信：channel。要用通信来共享内存，不要用共享内存来通信。

## 二、进程间通信有哪些方式？它们的区别？ 

1. 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在有血缘关系的进程间使用，进程的血缘关系通常是指父子进程关系。 
2. 命名管道（named pipe）：也是半双工的通信方式，但是它允许无亲缘关系关系进程间通信。
3. 套接字（socket）：套接口也是进程间的通信机制，与其他通信机制不同的是它可用于不同机器间的进程通信。 
4. 信号（signal）：是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。 
5. 信号量（semophere）：信号量是一个计数器，可用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 消息队列（message queue）:消息队列是由消息组成的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递消息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
7. 共享内存（shared memory）:就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量等配合使用，来实现进程间的同步和通信。 

### 几种通信方式的比较

管道：速度慢、容量有限 
消息队列：容量收到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。 
信号量：不能传递复杂信息，只能用来同步。 
共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。

## 三、线程间的通信机制  

1. 锁机制：互斥锁、条件变量、读写锁 
互斥锁：提供了以排他方式防止数据结构被并发修改的方法。 
读写锁：允许多个线程同时读共享数据，而对写操作是互斥的。 
条件变量：可以以原子的方式进行阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
2. 信号量机制：包括无名信号量和命名线程信号量 
3. 信号机制：类似进程间的信号处理 
### 比较
线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。



## 四、Windows下的内存是如何管理的 

 3种： 
1. 虚拟内存： 
最适合用来管理大型对象或者结构数组 
2. 内存映射文件： 
最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据 
3. 内存堆栈： 
最适合用来管理大量的小对象 

## 五、中断和轮询的特点 

对I/O设备的程序轮询的方式，是早期的计算机系统对I/O设备的一种管理方式。它定时对各种设备轮流询问一遍有无处理要求。轮流询问之后，有要求的就加以处理。在处理I/O设备的要求之后，处理机返回继续工作。尽管轮询需要时间，但轮询要比I/O设备的速度要快得多，所以一般不会发生不能及时处理的问题。当然，再快的处理机，能处理的输入输出设备的数量也是有一定限度的。而且，程序轮询毕竟占据了CPU相当一部分处理时间，因此程序轮询是一种效率较低的方式，现代计算机系统中已很少应用。 
　　轮询效率低，等待时间很长，CPU利用率不高；中断容易遗漏一些问题，CPU利用率高。

## 六、什么是临界区、如何解决冲突？ 

每个进程中访问临界资源的那段程序称为临界区，每次只准许一个进程进入临界区，进入后不允许其他进程进入。如果有若干个进程要求进入空闲的临界区，一次仅允许一个进程进入。任何时候，处于临界区的进程不可多于一个。如已有进程进入自己的临界区，则其他试图进入临界区的进程必须等待。进入临界区的进程要在有限时间内退出，以便其他进程能及时进入自己的临界区。如果不能进入自己的临界区，就应该让出CPU，避免进程出现忙等等现象。

## 七、 分段和分页的区别？

### 分段机制
分段机制就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元。
每个段由三个参数定义：段基地址、段限长和段属性。
段的基地址、段限长以及段的保护属性存储在一个称为段描述符的结构项中。
段可以用来存放程序的代码、数据和堆栈，或者用来存放系统数据结构。
系统中所有使用的段都包含在处理器线性地址空间中。
逻辑地址包括一个段选择符或一个偏移量，段选择符是一个段的唯一标识，提供了段描述符表，段描述符表指明短的大小、访问权限和段的特权级、段类型以及段的第一个字节在线性地址空间中的位置（称为段的基地址）。逻辑地址的偏移量部分到段的基地址上就可以定位段中某个字节的位置。因此基地址加上偏移量就形成了处理器线性地址空间中的地址。

![image](http://images.cnitblog.com/blog/525372/201401/211729348199.png)

### 分页机制
分页机制在段机制之后进行的，它进一步将线性地址转换为物理地址。
分页机制支持虚拟存储技术，在使用虚拟存储的环境中，大容量的线性地址空间需要使用小块的物理内存（RAM或ROM）以及某些外部存储空间来模拟。当使用分页时，每个段被划分成页面（通常每页为4K大小），页面会被存储于物理内存中或硬盘中。操作系统通过维护一个页目录和一些页表来留意这些页面。当程序（或任务）试图访问线性地址空间中的一个地址位置时，处理器就会使用页目录和页表把线性地址转换成一个物理地址，然后在该内存位置上执行所要求的操作。
### 分段和分页的区别
1、分页机制会使用大小固定的内存块，而分段管理则使用了大小可变的块来管理内存。
2、分页使用固定大小的块更为适合管理物理内存，分段机制使用大小可变的块更适合处理复杂系统的逻辑分区。
3、段表存储在线性地址空间，而页表则保存在物理地址空间。

### 页面置换算法

 若其所要访问的页面不在内存而需要把它们调入内存，但是内存已无空闲空间时，系统必须从内存中调出一个页面到磁盘对换区中，并且将程序所需要的页面调入内存中。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 
1. 最佳（Optimal）
所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。
2. 先进先出（FIFO）
所选择换出的页面是最先进入的页面。
3. 最近最久未使用（LRU, Least Recently Used）
4. 时钟（Clock）
Clock 页面置换算法需要用到一个访问位，当一个页面被访问时，将访问为置为 1。
首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。

## 八、什么是死锁？产生条件？如何避免死锁 
死锁的概念：在2个或多个并发进程中，如果每个进程持有某有资源而又都等待别的进程释放它或他们现在保持的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是2个或多个进程被无限期地阻塞、相互等待的一种状态。 
死锁产生的原因：系统资源不足，进程推进顺序非法 
产生死锁的必要条件： 
1. 互斥条件：一个资源每次只能被一个进程使用 
2. 不可剥夺条件：进程已获得资源，在未使用完之前，不能被其他进程强行剥夺，只能主动释放 
3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。 
4. 循环等待条件：即进程集合{p0,p1,p2,p3…..pn};p0正在等待p1占用的资源，p1正在等待p2占用的资源，pn正在等待p0占用的资源。 
　只要上述一个条件不成立，就不会发生死锁。 
死锁的解除和预防：理解了死锁的原因，以及产生死锁的四个必要条件，就可以最大可能地避免和预防和解锁死锁。所以在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。对资源的分配要给予合理规划 
死锁的处理策略：鸵鸟策略、预防策略、避免策略、检测与解除死锁

## 九、进程间同步与互斥的区别，线程同步的方式？
互斥：指某一个资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的 
同步：是指在互斥的基础上（大多数情况下），通过其它机制实现访问者对资源的有序访问。大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
同步：体现的是一种协作性。互斥：体现的是排它性。 
进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的诸进程之间能有效地共享资源和相互合作。从而使程序的执行具有可再现性。 
线程同步的方式： 
　　临界区、互斥量、信号量、事件 
　　临界区：通过对多线程的串行化来访问公共资源或者一段代码，速度快，适合控制数据访问。 
　　互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会同时被多个线程访问。 
　　信号量：它允许多个线程同一时刻访问同一资源，但是需要限制同一时刻访问此资源的最大线程数目。信号量对象与其他前面几种方法不同，信号允许多个线程同时使用共享资源。 
　　事件（信号）：通过通知操作的方式来保持多线程的同步，还可以方便实现多线程的优先级比较操作。 
　　
## 十、进程的调度算法有哪些？
1. 先来先服务（FCFS）:此算法的原则是按照作业到达后备作业队列（或进程进入就绪队列）的先后次序选择作业（或进程） 

2. 短作业优先（SJF:Shortest Process First）：这种算法主要用于作业调度，它从作业后备序列中挑选所需运行时间最短的作业进入主存运行。 

3. 时间片轮转调度算法：当某个进程执行的时间片用完时，调度程序便终止该进程的执行，并将它送到就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证队列中的所有进程，在已给定的时间内，均能获得一时间片处理机执行时间。 

4. 高响应比优先：按照高响应比（已等待时间+要求运行时间）/要求运行时间 优先的原则，在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP。选择最大的作业投入运行。 

5. 优先权调度算法：按照进程的优先权大小来调度。使高优先权进程得到优先处理的调度策略称为优先权调度算法。注意：优先数越多，优先权越小。 

6. 多级队列调度算法：多队列调度是根据作业的性质和类型的不同，将就绪队列再分为若干个队列，所有的作业（进程）按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。

   

