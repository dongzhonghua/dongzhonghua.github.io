[TOC]

## redis 分布式锁

### 如何用Redis打造分布式锁

一般情况下我们想到的是`setnx` ，抢占到一个’坑位‘之后，这个锁就抢占成功了，业务逻辑完成之后在`del`。但是这样存在一个问题。如果抢到锁之后出现异常了。锁来不及释放，就造成了死锁。

于是可以在拿到锁之后加一个过期时间，这样即使某个线程出现问题，也可以及时释放掉锁。

但是这样还是有问题，如果在setnx和expire之间服务器进程突然挂掉了或者服务器宕机了，就会导致expire得不到执行。

这种问题的根源是setnx和expire不是一个原子操作。redis的事务可以保证两个在一起操作，但是在这里不行，因为expire是依赖于setnx的结果的，如果没抢不到锁，expire就不应该执行。

为了解决这个问题，在Redis2.8版本加入了set指令的拓展参数。使得setnx和expire可以一起执行。

### 超时问题

Redis分布式锁不能解决超时问题，如果业务执行时间过长，超出了锁的超时时间，其他的业务就会获取到锁。

一个解决方案是获取锁时set一个随机数，删除时先判断是不是之前set的值，是的话再删除，但是判断和删除也不是一个原子操作。针对这个情况，Redis可以用Lua脚本来解决。但是使用lua也不能解决过期问题。所以Redis的分布式锁尽量用在业务时间不是很长的场景下，或者使用[RedLock](Redis分布式锁RedLock.md)。

### 可重入性

可重入性指线程持有锁的情况下再次获取锁。

Redis获取可重入锁的方式是使用ThreadLocal，如果获取锁成功，则把当前锁的名称保存在ThreadLocal中的Map里，每获取一次就将锁引用计数加一。删除锁的时候则先看引用计数，然后再删除锁。

### 集群情况

[Redis集群](Redis主从哨兵cluster集群.md)



