

[toc]

# 索引----------------------------------

![img](https://raw.githubusercontent.com/dongzhonghua/dongzhonghua.github.io/master/img/blog/16be43697f1c1732.png)

# 聚簇索引

索引和数据存储在一块（ 都存储在同一个B*tree 中）。
一般主键索引都是聚餐索引

InnoDB引擎的主键索引为聚簇索引，MyISAM是非聚簇索引

## 聚簇索引优点

1.  因为聚簇索引页是通过双向链表链接，页按照主键的顺序排序，聚簇索引能针对范围和主键排序进行查找。
2.  聚簇索引更快，非聚簇索引定位到主键后还要多一次目标记录寻址，多一次I/O。
3.  

## 聚簇索引缺点

1.  插入速度严重依赖与顺序。索引对于InnoDB来说。我们一般都会定义一个自增的Id为主键。
2.  更新主键代价高。
3.  二级索引访问需要两次查找。第一次查找主键。第二次找到行。
    -   二级索引存储主键，而不是行指针（非聚簇索引存储指针或者地址），这是为了减少当出现行移动或数据页分裂时候的二级索引维护工作。
4.  插入新值要慢很多。

# 非聚簇索引

索引数据和存储数据是分离的。

# 二级索引（辅助索引）

二级索引存储的是记录的主键，而不是数据存储的地址。

以InnoDB为例，主键是聚集索引。

![数据库b+tree(InnoDB)](https://raw.githubusercontent.com/dongzhonghua/dongzhonghua.github.io/master/img/blog/%E6%95%B0%E6%8D%AE%E5%BA%93b%2Btree(InnoDB).png)

唯一索引、普通索引、前缀索引等都是二级索引（辅助索引）

一个表中的所有索引除了聚集索引，其他的都是二级索引（secondary index）

通过辅助索引查找数据时，首先遍历辅助索引，找到指向主键索引的主键，在通过主键索引找到一个完整的行记录。



# 覆盖索引

举个例子，某个数据库建立了联合索引：

```sql
ALTER TABLE student ADD INDEX idx_name_age(name, age);
```

如果要执行以下SQL：

```sql
SELECT age FROM student WHERE name = '小李'；
```



流程为：

1.  在name,age联合索引树上找到名称为小李的节点
2.  此时节点索引里包含信息age 直接返回 12

此时没有走主索引，所以叫做索引覆盖。

# Hash索引

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

hash索引只有精确匹配索引所有列的查询才有效。

因为索引自身只需要存储对应该hash值，所以索引结构十分紧凑，速度快的同时也有很多限制。

1.  只包含Hash值和行指针，不存储字段，不能是有索引中的值才避免读取行。
2.  无法用于排序。
3.  (a,b)上简历hash索引，如果只查a，则无法使用该索引。
4.  只支持等值比较，不支持范围查询。
5.  hash冲突。

## 自适应hash索引

![img](https://raw.githubusercontent.com/dongzhonghua/dongzhonghua.github.io/master/img/blog/1113510-20170830183917780-959160821.png)

维护索引叶页面中所有记录的索引键值(或键值前缀)到索引叶页面位置的Hash映射关系,
能够根据索引键值(前缀)快速定位到叶页面满足条件记录的Offset，减少了B+树Search Path的代价，将B+树从Root页面至Leaf页面的路径定位，优化为Hash Index的快速查询。

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。

![](https://raw.githubusercontent.com/dongzhonghua/dongzhonghua.github.io/master/img/blog/16be436eae467104.png)

# 全文检索

第一行中B+树索引是可以支持的，但是第二行就必须进行全文索引。

```sql
select * from blog where content like 'xxx%';
select * from blog where content like '%xxx%';
```

InnoDB使用倒排索引来实现全文检索，这也是搜索引擎的核心技术。

---

# 锁---------------------------------------

锁的类型：

-   共享锁，允许事务读一行数据。
-   排它锁，允许事务删除或者更新一行数据。



# 事务-------------------------------------

# 四大事务

**数据库事务的四大特性：**

1.  **原子性**：事务包含的所有数据库操作要么全部成功，要不全部失败回滚

2.  **一致性**：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3.  **隔离性**：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：**read_uncommit，read_commit，read_repeatable，Serializable 串行化访问**。

4.  **持久性**：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

# 事务隔离级别

-   **读未提交（READ UNCOMMITTED）**：一个事务还没提交时，它做的变更就能被别的事务看到。

-   **读提交（READ COMMITTED）**：一个事务提交之后，它做的变更才会被其他事务看到。

-   **可重复读（REPEATABLE READ）**：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

-   **串行化（SERIALIZABLE)**：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

隔离级别解决的问题：

-   **脏读（dirty read）**：如果一个事务A读到了另一个未提交事务B修改过的数据，这个时候B可能回滚，然后A读到的就是脏数据。
-   **不可重复读（non-repeatable read）（针对update，读取内容）**：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。
-   **幻读（phantom read）（针对insert，delete，数据总量）**：事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

**不可重复读和幻读到底有什么区别呢？**

(1) 不可重复读是读取了其他事务更改的数据，**针对update操作**

解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

(2) 幻读是读取了其他事务新增的数据，**针对insert和delete操作**

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

这时候再理解事务隔离级别就简单多了呢。

![image-20200629233256825](https://raw.githubusercontent.com/dongzhonghua/dongzhonghua.github.io/master/img/blog/image-20200629233256825.png)

